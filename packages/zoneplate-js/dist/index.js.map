{"version":3,"file":"index.js","sources":["../lib/index.js"],"sourcesContent":["\n\n// data is a width*height*4 Uint8ClampedArray\n\nexport function renderJS (data, width, height, frames, t, cx2, cy2, cxt, cyt, ct) {\n  const cx = width / 2\n  const cy = height / 2\n\n  // originally: x=(i/W), y=(j/H) both in [0,1]\n  // phi = cx2 * x^2*W + cy2*y^2*H + cxt*x*t*F*F/2 + cyt*y*t*F*F/2 + ct*t*F\n\n  let index = 0\n  const ctt = ct * frames * t\n\n  for (let j = -cy; j < height - cy; j++) {\n    const cy2y2 = (cy2) ? (cy2 * j * j / height) : 0\n    const cytyt = (cyt) ? (cyt * (j / height) * (t * frames * frames / 2)) : 0\n    const cy2y2cytytctt = cy2y2 + cytyt + ctt\n    for (let i = -cx; i < width - cx; i++) {\n      const cx2x2 = (cx2) ? (cx2 * i * i / width) : 0\n\n      // TODO: this is not periodic in t : same goes for cytyt\n      //  but we have phi(t)==phi(frames-t) ..check?\n      const cxtxt = (cxt) ? (cxt * (i / width) * (t * frames * frames / 2)) : 0\n\n      const phi = (cx2x2 + cxtxt + cy2y2cytytctt) * Math.PI\n\n      // Inline trig calculation - Math.cos - Way Slower\n      // const c = Math.floor(Math.cos(phi) * 126 + 127)\n\n      // Use the Cosine lookup table - Slower\n      // const c = Cosine(phi)\n\n      // Use the Cosine lookup table - with inlined index calc\n      const absPhi = (phi < 0) ? -phi : phi\n      const iPhi = Math.floor(Q * absPhi / (2 * Math.PI)) % Q\n      const c = cosineLookup[iPhi]\n\n      // yellow = red+green\n      data[index + 0] = c // red\n      data[index + 1] = c // green\n      data[index + 2] = 0 // blue\n      // data[index + 3] = 255 // alpha // set once in getCachedImageData\n      index += 4\n    }\n  }\n  // ctx.putImageData(imageData, 0, 0)\n}\n\nconst Q = 1024\nconst cosineLookup = Array.from({ length: Q }, (_, iPhi) => {\n  const phi = iPhi * 2 * Math.PI / Q\n  return Math.cos(phi) * 126.0 + 127.0\n})\n\n// This index calculation was inlined for performance\n// So commented for possible future use\n// function Cosine (phi) {\n//   const absPhi = (phi < 0) ? -phi : phi\n//   const iPhi = Math.floor(Q * absPhi / (2 * Math.PI)) % Q\n//   return cosineLookup[iPhi]\n// }\n"],"names":["Q","cosineLookup","Array","from","length","_","iPhi","phi","Math","PI","cos","data","width","height","frames","t","cx2","cy2","cxt","cyt","ct","cx","cy","index","ctt","j","cy2y2cytytctt","i","floor","c"],"mappings":"AAiDA,IAAMA,EAAI,KACJC,EAAeC,MAAMC,KAAK,CAAEC,OAAQJ,GAAK,SAACK,EAAGC,GACjD,IAAMC,EAAa,EAAPD,EAAWE,KAAKC,GAAKT,EACjC,OAAuB,IAAhBQ,KAAKE,IAAIH,GAAe,gCAhDPI,EAAMC,EAAOC,EAAQC,EAAQC,EAAGC,EAAKC,EAAKC,EAAKC,EAAKC,GAU5E,IATA,IAAMC,EAAKT,EAAQ,EACbU,EAAKT,EAAS,EAKhBU,EAAQ,EACNC,EAAMJ,EAAKN,EAASC,EAEjBU,GAAKH,EAAIG,EAAIZ,EAASS,EAAIG,IAIjC,IAHA,IAEMC,GAFST,EAAQA,EAAMQ,EAAIA,EAAIZ,EAAU,IAChCM,EAAQA,GAAOM,EAAIZ,IAAWE,EAAID,EAASA,EAAS,GAAM,GACnCU,EAC7BG,GAAKN,EAAIM,EAAIf,EAAQS,EAAIM,IAAK,CACrC,IAMMpB,IANSS,EAAQA,EAAMW,EAAIA,EAAIf,EAAS,IAI/BM,EAAQA,GAAOS,EAAIf,IAAUG,EAAID,EAASA,EAAS,GAAM,GAE3CY,GAAiBlB,KAAKC,GAU7CH,EAAOE,KAAKoB,MAAM5B,GADRO,EAAM,GAAMA,EAAMA,IACI,EAAIC,KAAKC,KAAOT,EAChD6B,EAAI5B,EAAaK,GAGvBK,EAAKY,EAAQ,GAAKM,EAClBlB,EAAKY,EAAQ,GAAKM,EAClBlB,EAAKY,EAAQ,GAAK,EAElBA,GAAS"}